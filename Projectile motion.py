# -*- coding: utf-8 -*-
"""FINAL portfolio

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11wDCWLIQUJMpTimZdN_ksUcaOcutzVJ-

# PORTFOLIO 1 - NUMERICAL SOLVERS AND MODELLING
# LABS AND DATA ANALYSIS 04 34042
# SANCHITA SENDIL 2430862

# Question 1
"""

import numpy as np
import matplotlib.pyplot as plt
from math import radians, hypot, cos, sin #importing math functions

def get_projectile(height=0,launch_angle=60,velocity=10, timestep=0.001): #creating a function to calculate projectile path
  g = -9.81 
  y = height #height
  x=0.0 #distance
  v = velocity #velocity
  theta=launch_angle #launch angle
  theta=np.radians(theta) 
  vx = v*np.cos(theta) #x and y components of velocity
  vy = v*np.sin(theta)
  analytical_range=-2*vx*vy/g
  print("range of projectile analytically obtained is", analytical_range)
  t = 0 #initial time
  dt = timestep #time step
  data = [] #empty array to store data
  while y>=0:
    data.append([t, y, x, v])
    vy = vy+g*dt #implementing Eulers methos
    y = y+vy*dt
    x = x+vx*dt
    v= hypot(vx,vy) #resultant of velocity components
    t += dt
  data = np.array(data).transpose()
  return data

data = get_projectile(height=0, launch_angle=60, velocity=10, timestep=0.001)
plt.plot(data[2], data[1]) #graph for x displacement and y height
plt.style.use('seaborn-whitegrid')
plt.title('Figure 1.1: trajectory for projectile launched at an angle')
plt.xlabel("position in x direction (m)")
plt.ylabel("position in y direction (m))")
xmax=max(data[2])
print("range of projectile obtained through Euler method is",xmax)

"""# Question 2"""

data_60 = get_projectile(height=0, launch_angle=60, velocity=10, timestep=0.001)
data_30 = get_projectile(height=0, launch_angle=30, velocity=10, timestep=0.001)
plt.style.use('seaborn-whitegrid')
fig, axes = plt.subplots(1, 2)
fig.set_size_inches(18, 6)
axes[0].set_title('Figure 2.1: Vertical displacement vs time with launch angle as 60 degrees')
axes[0].set_xlabel('time (s)')
axes[0].set_ylabel('displacement in y direction (m)')
axes[1].set_title('Figure 2.2:  Vertical displacement vs time with launch angle as 30 degrees')
axes[1].set_xlabel('time (s)')
axes[1].set_ylabel('displacement in y direction (m)')
axes[0].plot(data_60[2], data_60[1], label = "ry(t) vs. t")
plt.grid()
axes[1].plot(data_30[2], data_30[1], label = "ry(t) vs. t")
plt.grid()
plt.show()

"""# Velocity Verlet method

"""

def get_projectile_velocityverlet(height=0,launch_angle=60,velocity=10, timestep=0.1):
  g = -9.81 
  y = height #height
  x=0.0 #distance
  v = velocity #velocity
  theta=launch_angle #launch angle
  theta=np.radians(theta) 
  vx = v*np.cos(theta) #x and y components of velocity
  vy = v*np.sin(theta)
  ax=0
  ay=-g
  t = 0 #initial time
  dt = timestep #time step
  data = [] #empty array to store data
  while y>=0:
    data.append([t, y, x, v])
    vy = vy+(g-ay)*dt*0.5
    y = y+vy*dt+(ay*dt**2*0.5) #velocity verlet method
    x = x+vx*dt+(ax*dt**2*0.5) #velocity verlet method
    v= hypot(vx,vy)
    t += dt
  data = np.array(data).transpose()
  return data

data_60 = get_projectile_velocityverlet(height=0, launch_angle=60, velocity=10, timestep=0.001)
data_30 = get_projectile_velocityverlet(height=0, launch_angle=30, velocity=10, timestep=0.001)
plt.style.use('seaborn-whitegrid')
fig, axes = plt.subplots(1, 2)
fig.set_size_inches(18, 6)
axes[0].set_title('Figure 2.3: Vertical displacement vs horizontal displacement with launch angle as 60 degrees')
axes[0].set_xlabel('displacement in x direction')
axes[0].set_ylabel('displacement in y direction (m)')
axes[1].set_title('Figure 2.4:  Vertical displacement vs horizontal displacement with launch angle as 30 degrees')
axes[1].set_xlabel('displacement in x direction')
axes[1].set_ylabel('displacement in y direction (m)')
axes[0].plot(data_60[2], data_60[1], label = "ry(t) vs. t")
plt.grid()
axes[1].plot(data_30[2], data_30[1], label = "ry(t) vs. t")
plt.grid()
plt.show()

"""# Question 3

"""

def get_projectile_hard_sphere(height=50,launch_angle=0,coeff_restitution=0.56,velocity=0, timestep =0.001): # creating a function for hard sphere projectile
  g = -9.81 
  y = height #height
  x=0.0 #distance
  v = velocity #velocity
  theta=launch_angle #launch angle
  theta=np.radians(theta) 
  vx = v*np.cos(theta) #x and y components of velocity
  vy = v*np.sin(theta)
  e=coeff_restitution #coefficent of restitution for steel ball
  t = 0 #initial time
  dt = timestep #time step
  data = [] #empty array to store data

  while t < 20: #while loop
      y += vy*dt #eulers method 
      x+=vx*dt
      if y > 0: #if loop for hard sphere height
          vy += g*dt 
      else:
          y=0
          vy = -e*vy   # adding the hard sphere bounce when sphere hits the ground
      v=hypot(vx,vy) #resultant of velocity
      data.append([t, y, x, v]) #adding data to empty list created at start
      t += dt
  data = np.array(data).transpose()
  return data

data = get_projectile_hard_sphere(height=50, coeff_restitution=0.56, velocity=0)
fig, axes = plt.subplots(1, 3)
fig.set_size_inches(18, 6)
axes[0].set_title('Figure 3.1: Horizontal displacement vs time')
axes[0].set_xlabel('time (s)')
axes[0].set_ylabel('displacement in x direction (m)')
axes[1].set_title('Figure 3.2: Vertical displacement vs time')
axes[1].set_xlabel('time (s)')
axes[1].set_ylabel('displacement in y direction (m)')
axes[2].set_title('Figure 3.3: Horizontal displacement vs Vertical displacement')
axes[2].set_xlabel('displacement in x direction (m)')
axes[2].set_ylabel('displacement in y direction (m)')

axes[0].plot(data[0], data[2], label = "rx(t) vs. t")
plt.grid()
axes[1].plot(data[0], data[1], label = "ry(t) vs. t")

axes[2].plot(data[2], data[1], label = "ry(t) vs. rx(t)")
plt.grid()
plt.show()

"""# Hard sphere bounce with drag force

"""

# Function which helps calculate  drag force for an object of given area in a medium of density rho.
# cd is the drag co efficient
def get_drag_force(velocity=0, area=0,rho=0, cd=0):
  drag = (cd * area * rho * (velocity ** 2 ))/ 2 # calculating drag force
  if velocity > 0:
    return -drag #drag acting in opposite direction to velocity
  else:
    return drag

# Function that calculates the position of an object using Eulers formula    
def get_projectile_hard_sphere_drag_force(height=0,launch_angle=0,elastic_coeff=1,velocity=0, timestep =0.001, radius=0,rho=0,density_ball=0,cd=0):
  g = 9.81 # acceleration due to gravity     
  y = height #height
  x=0.0 #distance
  v = velocity #velocity
  theta = launch_angle #launch angle
  theta = np.radians(theta) 
  vx = v*np.cos(theta) #x and y components of velocity
  vy = v*np.sin(theta)
  e = elastic_coeff #coefficent of restitution for steel ball
  area = 4*np.pi*radius**2
  volume = np.pi * 4 / 3 *radius**3
  mass = volume*density_ball
  f_bouyance = volume * rho

  t = 0 #initial time
  dt = timestep #time step
  data = [] #empty array to store data
  
  while t < 20: #while loop
      y+= vy*dt # implementing eulers method 
      x+= vx*dt
      
      ax =  0 +(1/mass) * (get_drag_force(vx,area,rho,cd) + f_bouyance) #including drag and buoyancy force
      ay = -g + (1/mass) * (get_drag_force(vy,area,rho,cd) + f_bouyance)
            
      if y> 0:
        vy = vy + ay * dt
      else:
        y=0 # Hit the ground
        vy = -e*vy # coefficient of restitution for bounce.
        
      v = hypot(vx,vy) #resultant of velocity
      
      data.append([t, y, x, v, ay]) #adding data to empty list created at start
      t += dt
  data = np.array(data).transpose()
  return data

data = get_projectile_hard_sphere_drag_force(height=50,elastic_coeff=0.56,velocity=0, timestep=0.001, radius=2.51e-3, rho=1.2, density_ball =7750,  cd=0.47)
plt.style.use('seaborn-notebook')
fig, axes = plt.subplots(1, 3)
fig.set_size_inches(18, 6)
axes[0].set_title('Figure 3.4: Horizontal displacement vs time')
axes[0].set_xlabel('time (s)')
axes[0].set_ylabel('displacement in x direction (m)')
axes[1].set_title('Figure 3.5: Vertical displacement vs time')
axes[1].set_xlabel('time (s)')
axes[1].set_ylabel('displacement in y direction (m)')
axes[2].set_title('Figure 3.6: Horizontal displacement vs Vertical displacement')
axes[2].set_xlabel('displacement in x direction (m)')
axes[2].set_ylabel('displacement in y direction (m)')

axes[0].plot(data[0], data[2], label = "rx(t) vs. t")
# plt.grid()
axes[1].plot(data[0], data[1], label = "ry(t) vs. t")
axes[2].plot(data[2], data[1], label = "ry(t) vs. rx(t)")
# plt.grid()
plt.show()